import java.util.regex.Matcher
import java.util.regex.Pattern

Pattern PLUGIN_NAME_PATTERN = Pattern.compile("(sonar-.*-plugin)(.*)")


/**
 * This module is building the zip file containing the static web site
 */

sonarqube {
  skipProject = true
}

group = 'com.sonarsource.sonarqube'

configurations {
  bundledPlugin {
    transitive = false
  }
}

// loads the bundled_plugins.gradle of each edition
// (they will all add there own bundled plugins to the bundledPlugin dependency configuration)
apply from: new File(rootDir, 'sonar-application/bundled_plugins.gradle')
File closeSourceDir = new File(rootDir, 'private');
if (closeSourceDir.exists()) {
  apply from: new File(closeSourceDir, 'edition-developer/bundled_plugins.gradle')
  apply from: new File(closeSourceDir, 'edition-enterprise/bundled_plugins.gradle')
  apply from: new File(closeSourceDir, 'edition-datacenter/bundled_plugins.gradle')
}

task extractAnalyzerDocFiles {
  doLast {
    configurations.bundledPlugin.files.each {
      File file = it
      copy {
        from(zipTree(file).matching { include 'static/documentation.md', 'META-INF/MANIFEST.MF' }) {
          eachFile { fcd ->
            if (fcd.getName().endsWith('.md')) {
              fcd.relativePath = new RelativePath(true, 'documentation' + '.md')
            } else {
              fcd.relativePath = new RelativePath(true, 'MANIFEST' + '.MF')
            }
          }
          includeEmptyDirs = false
        }
        Matcher m = PLUGIN_NAME_PATTERN.matcher(file.getName())
        if (m.find()) {
          into "$buildDir/tmp/plugin-documentation/" + m.group(1)
        }

      }
    }
  }
}

task yarn_run(type: Exec) {
  def docsVersion = version.split("[.-]").take(2).join('.')
  inputs.property('version', docsVersion)
  inputs.file(rootProject.file('build.gradle'));
  inputs.dir('src').withPathSensitivity(PathSensitivity.RELATIVE)
  ['build.gradle', 'gatsby-config.js', 'gatsby-node.js', 'package.json', 'yarn.lock', 'tsconfig.json'].each {
    inputs.file(it).withPathSensitivity(PathSensitivity.RELATIVE)
  }
  outputs.dir('public')
  outputs.cacheIf { true }

  environment += [ GATSBY_DOCS_VERSION: docsVersion ]
  commandLine osAdaptiveCommand(['npm', 'run', 'build'])
}
yarn_run.dependsOn(extractAnalyzerDocFiles)
build.dependsOn(yarn_run)

// To clean outputs outside of "build" directory:
clean.dependsOn(cleanYarn_run)

task "yarn_check-ci"(type: Exec) {
  // Note that outputs are not relocatable, because contain absolute paths, and that's why inputs are not relativized
  ['config', 'src'].each {
    inputs.dir(it)
  }
  ['package.json', 'yarn.lock', 'tsconfig.json'].each {
    inputs.file(it)
  }

  commandLine osAdaptiveCommand(['npm', 'run', 'check-ci'])
}

task "yarn_validate-ci"(type: Exec) {
  // Note that outputs are not relocatable, because contain absolute paths, and that's why inputs are not relativized
  ['config', 'src'].each {
    inputs.dir(it)
  }
  ['package.json', 'yarn.lock', 'tsconfig.json', '.eslintrc'].each {
    inputs.file(it)
  }
  outputs.cacheIf { true }

  commandLine osAdaptiveCommand(['npm', 'run', 'validate-ci'])
}

// Check for known vulnerabilities
task dependency_audit(type: Exec) {
  inputs.file('package.json')
  outputs.cacheIf { false }
  ignoreExitValue = true

  commandLine osAdaptiveCommand(['npm', 'run', 'audit-ci'])
}

task dependencyCheckAggregate_prerequisites(type: Exec) {
  // the OWASP tool does not support yarn and its yarn.lock files, so node modules
  // should be explicitly installed (yarn install) before running the audit
  // See https://github.com/jeremylong/DependencyCheck/issues/2393
  commandLine osAdaptiveCommand(['yarn', 'install', '--immutable'])
}

task zip(type: Zip) {
  def archiveDir = "$version"
  duplicatesStrategy DuplicatesStrategy.EXCLUDE
  baseName "sonar-docs"

  into("${archiveDir}") {
    from tasks.getByName('yarn_run').outputs
  }
}
zip.dependsOn yarn_run
assemble.dependsOn zip

publishing {
  publications {
    docs(MavenPublication) {
      artifactId 'sonar-docs'
      artifact zip
    }
  }
}

artifactory {
  publish {
    repository {
      repoKey = System.getenv('ARTIFACTORY_DEPLOY_REPO_PRIVATE')
      username = System.getenv('ARTIFACTORY_DEPLOY_USERNAME') ?: project.properties.artifactoryUsername
      password = System.getenv('ARTIFACTORY_DEPLOY_PASSWORD') ?: project.properties.artifactoryPaswword
    }
    defaults {
      properties = [
          'build.name'      : 'sonar-enterprise',
          'build.number'    : System.getenv('BUILD_NUMBER'),
          'pr.branch.target': System.getenv('GITHUB_BASE_BRANCH'),
          'pr.number'       : System.getenv('PULL_REQUEST'),
          'vcs.branch'      : System.getenv('GITHUB_BRANCH'),
          'vcs.revision'    : System.getenv('GIT_SHA1'),
          'version'         : version
      ]
      publishPom = true
      publishIvy = false
    }
  }
}

artifactoryPublish {
  skip = false
  publishPom = false
  publications(publishing.publications.docs)
}

def sources = fileTree(dir: "src") + fileTree(dir: "config") + fileTree(dir: "plugins") + file("gatsby-config.js") + file("gatsby-node.js")

task licenseCheckWeb(type: com.hierynomus.gradle.license.tasks.LicenseCheck) {
  source = sources
}
licenseMain.dependsOn licenseCheckWeb

task licenseFormatWeb(type: com.hierynomus.gradle.license.tasks.LicenseFormat) {
  source = sources
}
licenseFormat.dependsOn licenseFormatWeb
